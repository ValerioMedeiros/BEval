
THEORY ProofList IS
_f(5) & _f(4) & _f(3) & _f(2) & _f(1) & _f(8) & _f(7) & _f(11) & _f(10) & _f(6) & _f(9) & Initialisation.1,(_f(12) => _f(13))

END
&

THEORY Formulas IS
("`Component constraints'" & btrue);
("`Used machines constraints'" & btrue);
("`Component properties'" & (1..16)*{id_reg_8}: FIN(NATURAL*{id_reg_8}) & not((1..16)*{id_reg_8} = {}) & (1..5)*{id_reg_16}: FIN(NATURAL*{id_reg_16}) & not((1..5)*{id_reg_16} = {}));
("`Seen and used machines properties'" & abs = %nn.(nn: INTEGER & 0<=nn | nn)\/%nn.(nn: INTEGER & nn+1<=0 | -nn) & is_zero16USHORT = %nat1.(nat1: USHORT | bool_bit(bool(nat1 = 0))) & is_negative = %w1.(w1: BYTE | w1(7)) & half8UCHAR = %ww.(ww: UCHAR | ww mod 16) & inc = %w1.(w1: BYTE | uchar_byte((byte_uchar(w1)+1) mod 256)) & dec = %w1.(w1: BYTE | uchar_byte(abs(byte_uchar(w1)-1) mod 256)) & simple_add8UCHAR = %(w1,w2).(w1: UCHAR & w2: UCHAR | (w1+w2) mod 256) & add8UCHAR = %(carry,w1,w2).(carry: BIT & w1: UCHAR & w2: UCHAR | (carry+w1+w2) mod 256,bool_bit(bool(carry+uchar_schar(w1)+uchar_schar(w2)+1<=0)),bool_bit(bool(UCHAR_MAX+1<=carry+w1+w2)),bool_bit(bool(16<=carry+half8UCHAR(w1)+half8UCHAR(w2))),bool_bit(bool((carry+w1+w2) mod 256 = 0))) & substract8UCHAR = %(carry,w1,w2).(carry: BIT & w1: UCHAR & w2: UCHAR | carry+w1+byte_uchar(bv_not(uchar_byte(w2)))+1 mod 256,bool_bit(bool(carry+uchar_schar(w1)-uchar_schar(w2)+1<=0)),bool_bit(bool(UCHAR_MAX+1<=carry+w1+w2)),bool_bit(bool(16<=carry+half8UCHAR(w1)+half8UCHAR(byte_uchar(bv_not(uchar_byte(w2)))+1))),bool_bit(bool(carry+w1+byte_uchar(bv_not(uchar_byte(w2)))+1 mod 256 = 0))) & add16USHORT = %(b1,w1,w2).(b1: BIT & w1: USHORT & w2: USHORT | (b1+w1+w2) mod 65536) & add_carryUSHORT = %(b1,w1,w2).(b1: BIT & w1: USHORT & w2: USHORT | bool_bit(bool(65537<=b1+w1+w2))) & add_halfcarryUSHORT = %(b1,w1,w2).(b1: BIT & w1: USHORT & w2: USHORT | bool_bit(bool(4097<=b1+w1 mod 4096+w2 mod 4096))) & sub16USHORT = %(b1,w1,w2).(b1: BIT & w1: USHORT & w2: USHORT | (b1+w1+bv16_ushort(bv_not(ushort_bv16(w2)))) mod 65536) & sub_carryUSHORT = %(b1,w1,w2).(b1: BIT & w1: USHORT & w2: USHORT | bool_bit(bool(65537<=w1-w2-b1))) & sub_halfcarryUSHORT = %(b1,w1,w2).(b1: BIT & w1: USHORT & w2: USHORT | bool_bit(bool(4097<=w1 mod 4096-w2 mod 4096-b1))) & inc_BV16 = %w1.(w1: BV16 | ushort_bv16((bv16_ushort(w1)+1) mod 65536)) & dec_BV16 = %w1.(w1: BV16 | ushort_bv16(abs(bv16_ushort(w1)-1) mod 65536)) & update_refresh_reg = %v0.(v0: BYTE | uchar_byte(128*v0(8)+(64*v0(7)+32*v0(6)+16*v0(5)+8*v0(4)+4*v0(3)+2*v0(2)+v0(1)) mod 128)) & instruction_next = %w1.(w1: USHORT | (w1+1) mod 65536) & instruction_jump = %(p0,e0).(p0: USHORT & e0: -126..129 | (p0+e0) mod 65536) & BIT = 0..1 & bit_not = %bb.(bb: BIT | 1-bb) & bit_and = %(b1,b2).(b1: BIT & b2: BIT & b1 = 1 & b2 = 1 | 1)\/%(b1,b2).(b1: BIT & b2: BIT & not(b1 = 1 & b2 = 1) | 0) & bit_or = %(b1,b2).(b1: BIT & b2: BIT & (b1 = 1 or b2 = 1) | 1)\/%(b1,b2).(b1: BIT & b2: BIT & not(b1 = 1) & not(b2 = 1) | 0) & bit_xor = %(b1,b2).(b1: BIT & b2: BIT & not(b1 = b2) | 1)\/%(b1,b2).(b1: BIT & b2: BIT & b1 = b2 | 0) & bool_bit = {TRUE|->1}\/{FALSE|->0} & BIT_VECTOR = seq(BIT)-{{}} & bv_catenate = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR | v1^v2) & phys_bv_index = %v1.(v1: BIT_VECTOR | 0..size(v1)-1) & bv_sub = %(bv,low,high).(bv: BIT_VECTOR & low: 0..size(bv)-1 & high: low..size(bv)-1 | %i0.(i0: 1..high-low+1 | bv(i0+low))) & bv_zero: 1..16 +-> BIT_VECTOR & dom(bv_zero) = 1..16 & bv_zero = %sz.(sz: 1..16 | (1..sz)*{0}) & bv_one: 1..16 +-> BIT_VECTOR & dom(bv_one) = 1..16 & bv_one = %sz.(sz: 1..16 | (1..sz)*{1}) & bv_not = %v1.(v1: BIT_VECTOR | %idx.(idx: 1..size(v1) | bit_not(v1(idx)))) & bv_and = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 1..size(v1) | bit_and(v1(idx),v2(idx)))) & bv_or = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 1..size(v1) | bit_or(v1(idx),v2(idx)))) & bv_xor = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 1..size(v1) | bit_xor(v1(idx),v2(idx)))) & bv_clear = %(v1,idx).(v1: BIT_VECTOR & idx: 0..15 | v1<+{idx+1|->0}) & bv_set = %(v1,idx).(v1: BIT_VECTOR & idx: 0..15 | v1<+{idx+1|->1}) & bv_get = %(v1,idx).(v1: BIT_VECTOR & idx: 0..15 | v1(idx+1)) & bv_put = %(v1,idx,bit).(v1: BIT_VECTOR & idx: 0..15 & bit: BIT | v1<+{idx+1|->bit}) & BYTE_INDEX = 1..8 & PHYS_BYTE_INDEX = 0..7 & BYTE = SET(bt).(bt: BIT_VECTOR & size(bt) = 8) & BYTE_ZERO: BYTE & BYTE_ZERO = bv_zero(8) & is_zero = %w1.(w1: BYTE | bool_bit(bool(w1(1)+w1(2)+w1(3)+w1(4)+w1(5)+w1(6)+w1(7)+w1(8) = 0))) & parity_even = %bv.(bv: BYTE | 1-(bv(1)+bv(2)+bv(3)+bv(4)+bv(5)+bv(6)+bv(7)+bv(8)) mod 2) & bitget = %(bt1,ii).(bt1: BYTE & ii: PHYS_BYTE_INDEX | bt1(ii+1)) & bitset = %(bt1,ii).(bt1: BYTE & ii: PHYS_BYTE_INDEX | bv_set(bt1,ii)) & bitclear = %(bt1,ii).(bt1: BYTE & ii: PHYS_BYTE_INDEX | bv_clear(bt1,ii)) & complement = %bt.(bt: BYTE | bv_not(bt)) & swap = %bt.(bt: BYTE | {1|->bt(5)}\/{2|->bt(6)}\/{3|->bt(7)}\/{4|->bt(8)}\/{5|->bt(1)}\/{6|->bt(2)}\/{7|->bt(3)}\/{8|->bt(4)}) & rotateleft = %bv.(bv: BYTE | {1|->bv(8)}\/{2|->bv(1)}\/{3|->bv(2)}\/{4|->bv(3)}\/{5|->bv(4)}\/{6|->bv(5)}\/{7|->bv(6)}\/{8|->bv(7)}) & rotateright = %bv.(bv: BYTE | {1|->bv(2)}\/{2|->bv(3)}\/{3|->bv(4)}\/{4|->bv(5)}\/{5|->bv(6)}\/{6|->bv(7)}\/{7|->bv(8)}\/{8|->bv(1)}) & get_upper_digit = %by.(by: BYTE | 8*by(8)+4*by(7)+2*by(6)+by(5)) & get_lower_digit = %by.(by: BYTE | 8*by(4)+4*by(3)+2*by(2)+by(1)) & BV16_INDX = 1..16 & PHYS_BV16_INDEX = 0..15 & BV16 = SET(bt).(bt: BIT_VECTOR & size(bt) = 16) & BV16_ZERO = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] & bv16_byte = %bv.(bv: BV16 | {1|->bv(9)}\/{2|->bv(10)}\/{3|->bv(11)}\/{4|->bv(12)}\/{5|->bv(13)}\/{6|->bv(14)}\/{7|->bv(15)}\/{8|->bv(16)},{1|->bv(1)}\/{2|->bv(2)}\/{3|->bv(3)}\/{4|->bv(4)}\/{5|->bv(5)}\/{6|->bv(6)}\/{7|->bv(7)}\/{8|->bv(8)}) & byte_bv16 = %(bv1,bv2).(bv1: BYTE & bv2: BYTE | bv1^bv2) & UCHAR_MAX = 255 & UCHAR_MIN = 0 & UCHAR = UCHAR_MIN..UCHAR_MAX & byte_uchar = %v0.(v0: BYTE | 128*v0(8)+64*v0(7)+32*v0(6)+16*v0(5)+8*v0(4)+4*v0(3)+2*v0(2)+1*v0(1)) & uchar_byte: UCHAR +-> BYTE & uchar_byte = %v0.(v0: UCHAR | [v0 mod 2/1,v0 mod 4/2,v0 mod 8/4,v0 mod 16/8,v0 mod 32/16,v0 mod 64/32,v0 mod 128/64,v0 mod 256/128]) & SCHAR_MAX = 127 & SCHAR_MIN = -128 & SCHAR = SCHAR_MIN..SCHAR_MAX & byte_schar = %v0.(v0: BYTE | (-128)*v0(8)+64*v0(7)+32*v0(6)+16*v0(5)+8*v0(4)+4*v0(3)+2*v0(2)+v0(1)) & schar_byte = %v0.(v0: SCHAR & 0<=v0 | [v0 mod 2/1,v0 mod 4/2,v0 mod 8/4,v0 mod 16/8,v0 mod 32/16,v0 mod 64/32,v0 mod 128/64,v0 mod 256/128])\/%v0.(v0: SCHAR & not(0<=v0) | [(v0+UCHAR_MAX+1) mod 2/1,(v0+UCHAR_MAX+1) mod 4/2,(v0+UCHAR_MAX+1) mod 8/4,(v0+UCHAR_MAX+1) mod 16/8,(v0+UCHAR_MAX+1) mod 32/16,(v0+UCHAR_MAX+1) mod 64/32,(v0+UCHAR_MAX+1) mod 128/64,(v0+UCHAR_MAX+1) mod 256/128]) & uchar_schar = %v1.(v1: UCHAR & v1<=SCHAR_MAX | v1)\/%v1.(v1: UCHAR & not(v1<=SCHAR_MAX) | v1-UCHAR_MAX+1) & schar_uchar = %v1.(v1: SCHAR & 0<=v1 | v1)\/%v1.(v1: SCHAR & not(0<=v1) | v1+UCHAR_MAX+1) & SSHORT_MIN = -32768 & SSHORT_MAX = 32767 & SSHORT = SSHORT_MIN..SSHORT_MAX & bv16_sshort = %v0.(v0: BV16 | (-32768)*v0(16)+16384*v0(15)+8192*v0(14)+4096*v0(13)+2048*v0(12)+1024*v0(11)+512*v0(10)+256*v0(9)+128*v0(8)+64*v0(7)+32*v0(6)+16*v0(5)+8*v0(4)+4*v0(3)+2*v0(2)+v0(1)) & sshort_bv16 = %v0.(v0: SSHORT & 0<=v0 | [v0 mod 2/1,v0 mod 4/2,v0 mod 8/4,v0 mod 16/8,v0 mod 32/16,v0 mod 64/32,v0 mod 128/64,v0 mod 256/128,v0 mod 512/256,v0 mod 1024/512,v0 mod 2048/1024,v0 mod 4096/2048,v0 mod 8192/4096,v0 mod 16384/8192,v0 mod 32768/16384,v0 mod 65536/32768])\/%v0.(v0: SSHORT & not(0<=v0) | [(v0+USHORT_MAX+1) mod 2/1,(v0+USHORT_MAX+1) mod 4/2,(v0+USHORT_MAX+1) mod 8/4,(v0+USHORT_MAX+1) mod 16/8,(v0+USHORT_MAX+1) mod 32/16,(v0+USHORT_MAX+1) mod 64/32,(v0+USHORT_MAX+1) mod 128/64,(v0+USHORT_MAX+1) mod 256/128,(v0+USHORT_MAX+1) mod 512/256,(v0+USHORT_MAX+1) mod 1024/512,(v0+USHORT_MAX+1) mod 2048/1024,(v0+USHORT_MAX+1) mod 4096/2048,(v0+USHORT_MAX+1) mod 8192/4096,(v0+USHORT_MAX+1) mod 16384/8192,(v0+USHORT_MAX+1) mod 32768/16384,(v0+USHORT_MAX+1) mod 65536/32768]) & ushort_sshort = %v1.(v1: USHORT & v1<=SSHORT_MAX | v1)\/%v1.(v1: USHORT & not(v1<=SSHORT_MAX) | v1-USHORT_MAX+1) & sshort_ushort = %v1.(v1: SSHORT & 0<=v1 | v1)\/%v1.(v1: SSHORT & not(0<=v1) | v1+USHORT_MAX+1) & schar_sshort = %(w1,w2).(w1: SCHAR & w2: SCHAR | bv16_sshort(byte_bv16(schar_byte(w1),schar_byte(w2)))) & USHORT_MAX = 65535 & USHORT_MIN = 0 & USHORT = USHORT_MIN..USHORT_MAX & bv16_ushort = %v0.(v0: BV16 | 32768*v0(16)+16384*v0(15)+8192*v0(14)+4096*v0(13)+2048*v0(12)+1024*v0(11)+512*v0(10)+256*v0(9)+128*v0(8)+64*v0(7)+32*v0(6)+16*v0(5)+8*v0(4)+4*v0(3)+2*v0(2)+1*v0(1)) & ushort_bv16 = %v0.(v0: UCHAR | [v0 mod 2/1,v0 mod 4/2,v0 mod 8/4,v0 mod 16/8,v0 mod 32/16,v0 mod 64/32,v0 mod 128/64,v0 mod 256/128,v0 mod 512/256,v0 mod 1024/512,v0 mod 2048/1024,v0 mod 4096/2048,v0 mod 8192/4096,v0 mod 16384/8192,v0 mod 32768/16384,v0 mod 65536/32768]) & uchar_ushort = %(w1,w2).(w1: UCHAR & w2: UCHAR | bv16_ushort(byte_bv16(uchar_byte(w1),uchar_byte(w2)))));
("`Included,imported and extended machines properties'" & PROGRAM_R_ADR = USHORT & DATA_R_ADR = USHORT & STACK_R_ADR = USHORT);
("`Component invariant'" & rgs8: (1..16)*{id_reg_8} +-> BYTE & pc: USHORT & sp: BV16 & ix: BV16 & iy: BV16 & i_: BYTE & r_: BYTE & iff1: BIT & iff2: BIT & im: BIT*BIT & io_ports: BYTE +-> BYTE & btrue & btrue);
("`Seen and used machines invariants'" & btrue);
("`Included,imported and extended machines invariants'" & mem: BV16 +-> BYTE);
("`Component assertions'" & btrue);
("`Seen and used machines assertions'" & abs: INTEGER +-> INTEGER & dom(abs) = INTEGER & is_zero16USHORT: USHORT +-> BIT & dom(is_zero16USHORT) = USHORT & is_negative: BYTE +-> BIT & dom(is_negative) = BYTE & half8UCHAR: UCHAR +-> UCHAR & dom(half8UCHAR) = UCHAR & inc: BYTE +-> BYTE & dom(inc) = BYTE & dec: BYTE +-> BYTE & dom(dec) = BYTE & simple_add8UCHAR: UCHAR*UCHAR +-> UCHAR & dom(simple_add8UCHAR) = UCHAR*UCHAR & add16USHORT: BIT*USHORT*USHORT +-> USHORT & dom(add16USHORT) = BIT*USHORT*USHORT & substract8UCHAR: BIT*UCHAR*UCHAR +-> UCHAR*BIT*BIT*BIT*BIT & dom(substract8UCHAR) = BIT*UCHAR*UCHAR & add_carryUSHORT: BIT*USHORT*USHORT +-> BIT & dom(add_carryUSHORT) = BIT*USHORT*USHORT & add_halfcarryUSHORT: BIT*USHORT*USHORT +-> BIT & dom(add_halfcarryUSHORT) = BIT*USHORT*USHORT & sub16USHORT: BIT*USHORT*USHORT +-> USHORT & dom(sub16USHORT) = BIT*USHORT*USHORT & sub_carryUSHORT: BIT*USHORT*USHORT +-> BIT & dom(sub_carryUSHORT) = BIT*USHORT*USHORT & sub_halfcarryUSHORT: BIT*USHORT*USHORT +-> BIT & dom(sub_halfcarryUSHORT) = BIT*USHORT*USHORT & inc_BV16: BV16 +-> BV16 & dom(inc_BV16) = BV16 & dec_BV16: BV16 +-> BV16 & dom(dec_BV16) = BV16 & update_refresh_reg: BYTE +-> BYTE & dom(update_refresh_reg) = BYTE & instruction_next: USHORT +-> USHORT & dom(instruction_next) = USHORT & instruction_jump: USHORT*(-126..129) +-> USHORT & dom(instruction_jump) = USHORT*(-126..129) & dom(is_zero16USHORT) = USHORT & ran(is_zero16USHORT) = BIT & dom(is_negative) = BYTE & ran(is_negative) = BIT & dom(half8UCHAR) = UCHAR & ran(half8UCHAR) = UCHAR & dom(inc) = BYTE & ran(inc) = BYTE & dom(dec) = BYTE & ran(dec) = BYTE & dom(simple_add8UCHAR) = UCHAR*UCHAR & ran(simple_add8UCHAR) = UCHAR & dom(add8UCHAR) = BIT*UCHAR*UCHAR & ran(add8UCHAR): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(substract8UCHAR) = BIT*UCHAR*UCHAR & ran(substract8UCHAR): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(add16USHORT) = BIT*USHORT*USHORT & ran(add16USHORT) = USHORT & dom(add_carryUSHORT) = BIT*USHORT*USHORT & ran(add_carryUSHORT) = BIT & dom(add_halfcarryUSHORT) = BIT*USHORT*USHORT & ran(add_halfcarryUSHORT) = BIT & dom(sub16USHORT) = BIT*USHORT*USHORT & ran(sub16USHORT) = USHORT & dom(sub_carryUSHORT) = BIT*USHORT*USHORT & ran(sub_carryUSHORT) = BIT & dom(sub_halfcarryUSHORT) = BIT*USHORT*USHORT & ran(sub_halfcarryUSHORT) = BIT & dom(inc_BV16) = BV16 & ran(inc_BV16) = BV16 & dom(dec_BV16) = BV16 & ran(dec_BV16) = BV16 & dom(update_refresh_reg) = BYTE & ran(update_refresh_reg) = BYTE & dom(instruction_next) = USHORT & ran(instruction_next) = USHORT & dom(instruction_jump) = USHORT*(-126..129) & ran(instruction_jump) = USHORT & dom(abs) = INT & ran(abs) = INT & 0 = schar_sshort(0,0) & 1 = 2**0 & 2 = 2**1 & 4 = 2**2 & 8 = 2**3 & 16 = 2**4 & 32 = 2**5 & 64 = 2**6 & 128 = 2**7 & 256 = 2**8 & 512 = 2**9 & 1024 = 2**10 & 2048 = 2**11 & 4096 = 2**12 & 8192 = 2**13 & 16384 = 2**14 & 32768 = 2**15 & 65536 = 2**16 & !bb.(bb: BIT => bit_not(bb) = 1-bb) & dom(bit_and) = BIT*BIT & ran(bit_not) = BIT & bit_not(0) = 1 & bit_not(1) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & dom(bit_and) = BIT*BIT & ran(bit_and) = BIT & bit_and(0,0) = 0 & bit_and(0,1) = 0 & bit_and(1,0) = 0 & bit_and(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 1 => bit_and(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 0 => bit_and(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !b1.(b1: BIT => bit_and(b1,0) = 0) & dom(bit_or) = BIT*BIT & ran(bit_or) = BIT & bit_or(0,0) = 0 & bit_or(0,1) = 1 & bit_or(1,0) = 1 & bit_or(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 1 => bit_or(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 0 => bit_or(b2,b1) = 0) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 1 => b1 = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 0 => b1 = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = bit_or(1,b3)) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(1,b1) = 1) & !b1.(b1: BIT => bit_or(0,b1) = b1) & dom(bit_xor) = BIT*BIT & ran(bit_xor) = BIT & bit_xor(0,0) = 0 & bit_xor(0,1) = 1 & bit_xor(1,0) = 1 & bit_xor(1,1) = 0 & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 1 => bit_xor(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 0 => bit_xor(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(1,b3)) & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & dom(bool_bit) = BOOL & ran(bit_xor) = BIT & bool_bit(TRUE) = 1 & bool_bit(FALSE) = 0 & !bb.(bb: BIT => bb = 0 or bb = 1) & !bb.(bb: BIT & not(bb = 0) => bb = 1) & !bb.(bb: BIT & not(bb = 1) => bb = 0) & !vec.(vec: BIT_VECTOR => size(vec)<=16) & bv_catenate: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_catenate) = BIT_VECTOR*BIT_VECTOR & phys_bv_index: BIT_VECTOR +-> POW(NATURAL) & dom(phys_bv_index) = BIT_VECTOR & bv_sub: BIT_VECTOR*(1..15)*(1..15) +-> BIT_VECTOR & dom(bv_sub) = BIT_VECTOR*(1..15)*(1..15) & bv_not: BIT_VECTOR +-> BIT_VECTOR & dom(bv_not) = BIT_VECTOR & bv_and: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_and) = BIT_VECTOR*BIT_VECTOR & bv_or: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_or) = BIT_VECTOR*BIT_VECTOR & bv_xor: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_xor) = BIT_VECTOR*BIT_VECTOR & bv_clear: BIT_VECTOR*(0..15) +-> BIT_VECTOR & dom(bv_clear) = BIT_VECTOR*(0..15) & bv_set: BIT_VECTOR*(0..15) +-> BIT_VECTOR & dom(bv_set) = BIT_VECTOR*(0..15) & bv_get: BIT_VECTOR*(0..15) +-> BIT & dom(bv_get) = BIT_VECTOR*(0..15) & bv_put: BIT_VECTOR*(0..15)*BIT +-> BIT_VECTOR & dom(bv_put) = BIT_VECTOR*(0..15)*BIT & !bv.(bv: BIT_VECTOR => size(bv_not(bv)) = size(bv)) & !(bv,indx).(bv: BIT_VECTOR & indx: 0..size(bv)-1 => bv_get(bv_not(bv_not(bv)),indx) = bv_get(bv,indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR => size(bv_catenate(v1,v2)) = size(v1)+size(v2)) & !(bv,low,high).(bv: BIT_VECTOR & low: 0..size(bv)-1 & high: 0..size(bv)-1 & low<=high => size(bv_sub(bv,low,high)) = high-low) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) => size(bv_and(v1,v2)) = size(v2)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) & indx: 0..size(v1)-1 => bv_get(bv_and(v1,v2),indx) = bv_get(bv_and(v2,v1),indx)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & size(v1) = size(v2) & size(v1) = size(v3) & indx: 0..size(v1)-1 => bv_get(bv_and(v1,bv_and(v2,v3)),indx) = bv_get(bv_and(bv_and(v1,v2),v3),indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 0..size(bv)-1 => bv_get(bv_and(bv,bv_zero(size(bv))),indx) = bv_get(bv_zero(size(bv)),indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 0..size(bv)-1 => bv_get(bv_and(bv,bv_one(size(bv))),indx) = bv_get(bv,indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) => size(bv_or(v1,v2)) = size(v1)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) & indx: 0..size(v1)-1 => bv_get(bv_or(v1,v2),indx) = bv_get(bv_or(v2,v1),indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) => size(bv_or(v1,v2)) = size(v2)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & size(v1) = size(v2) & size(v1) = size(v3) & indx: 0..size(v1)-1 => bv_get(bv_or(v1,bv_or(v2,v3)),indx) = bv_get(bv_or(bv_or(v1,v2),v3),indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 0..size(bv)-1 => bv_get(bv_or(bv,bv_one(size(bv))),indx) = bv_get(bv_one(size(bv)),indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 0..size(bv)-1 => bv_get(bv_or(bv,bv_zero(size(bv))),indx) = bv_get(bv,indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) => size(bv_xor(v1,v2)) = size(v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) => size(bv_xor(v1,v2)) = size(v2)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) & indx: 0..size(v1)-1 => bv_get(bv_xor(v1,v2),indx) = bv_get(bv_xor(v2,v1),indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 0..size(bv)-1 => bv_get(bv_xor(bv,bv),indx) = bv_get(bv_zero(size(bv)),indx)) & card(BYTE) = 256 & is_zero: BYTE +-> BIT & dom(is_zero) = BYTE & is_zero: BYTE +-> BIT & dom(is_zero) = BYTE & parity_even: BYTE +-> BIT & dom(parity_even) = BYTE & bitget: BYTE*PHYS_BYTE_INDEX +-> BIT & dom(bitget) = BYTE*PHYS_BYTE_INDEX & bitset: BYTE*PHYS_BYTE_INDEX +-> BYTE & dom(bitset) = BYTE*PHYS_BYTE_INDEX & bitclear: BYTE*PHYS_BYTE_INDEX +-> BYTE & dom(bitclear) = BYTE*PHYS_BYTE_INDEX & complement: BYTE +-> BYTE & dom(complement) = BYTE & swap: BYTE +-> BYTE & dom(swap) = BYTE & rotateleft: BYTE +-> BYTE & dom(rotateleft) = BYTE & rotateright: BYTE +-> BYTE & dom(rotateright) = BYTE & size(BYTE_ZERO) = 8 & BYTE: POW(BIT_VECTOR) & BYTE_ZERO: BIT_VECTOR & first(BYTE_ZERO) = 0 & !bt.(bt: BYTE => size(bt) = 8 & bt: seq(BIT) & not(bt = {})) & 8: INTEGER & btrue & dom(is_zero) = BYTE & ran(is_zero) = BIT & dom(parity_even) = BYTE & ran(parity_even) = BIT & dom(bitget) = BYTE*PHYS_BYTE_INDEX & ran(bitget) = BIT & dom(bitset) = BYTE*PHYS_BYTE_INDEX & ran(bitset) = BYTE & dom(bitclear) = BYTE*PHYS_BYTE_INDEX & ran(bitclear) = BYTE & dom(complement) = BYTE & ran(complement) = BYTE & dom(swap) = BYTE & ran(swap) = BYTE & dom(rotateleft) = BYTE & ran(rotateleft) = BYTE & dom(rotateright) = BYTE & ran(rotateright) = BYTE & dom(get_upper_digit) = BYTE & ran(get_upper_digit) = 0..15 & dom(get_lower_digit) = BYTE & ran(get_lower_digit) = 0..15 & [1,1,1,1,1,1,1,1]: BYTE & [0,0,0,0,0,0,0,0]: BYTE & 1 = 2**0 & 2 = 2**1 & 4 = 2**2 & 8 = 2**3 & 16 = 2**4 & 32 = 2**5 & 64 = 2**6 & 128 = 2**7 & 256 = 2**8 & 512 = 2**9 & 1024 = 2**10 & 2048 = 2**11 & 4096 = 2**12 & 8192 = 2**13 & 16384 = 2**14 & 32768 = 2**15 & 65536 = 2**16 & BV16_ZERO: BV16 & BV16: POW(BIT_VECTOR) & card(BV16) = 65536 & !bt.(bt: BV16 => size(bt) = 16 & bt: seq(BIT) & not(bt = {})) & [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]: BV16 & [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]: BV16 & card(byte_uchar) = 256 & card(uchar_byte) = 256 & uchar_byte = byte_uchar~ & UCHAR_MAX: INTEGER & UCHAR_MIN: INTEGER & dom(byte_uchar) = BYTE & ran(byte_uchar) = UCHAR & dom(uchar_byte) = UCHAR & ran(uchar_byte) = BYTE & 1 = 2**0 & 2 = 2**1 & 4 = 2**2 & 8 = 2**3 & 16 = 2**4 & 32 = 2**5 & 64 = 2**6 & 128 = 2**7 & 256 = 2**8 & card(uchar_schar) = 256 & card(schar_uchar) = 256 & SCHAR_MAX: INTEGER & SCHAR_MIN: INTEGER & dom(byte_schar) = BYTE & ran(byte_schar) = SCHAR & dom(schar_byte) = SCHAR & ran(schar_byte) = BYTE & schar_uchar = uchar_schar~ & schar_byte = byte_schar~ & 1 = 2**0 & 2 = 2**1 & 4 = 2**2 & 8 = 2**3 & 16 = 2**4 & 32 = 2**5 & 64 = 2**6 & 128 = 2**7 & 256 = 2**8 & card(bv16_sshort) = 65536 & card(sshort_bv16) = 65536 & card(schar_sshort) = 65536 & card(ushort_sshort) = 65536 & card(sshort_ushort) = 65536 & SSHORT_MIN: SSHORT & SSHORT_MAX: SSHORT & sshort_bv16 = bv16_sshort~ & schar_sshort: SCHAR*SCHAR +-> SSHORT & dom(schar_sshort) = SCHAR*SCHAR & dom(bv16_sshort) = BV16 & ran(bv16_sshort) = SSHORT & dom(sshort_bv16) = SSHORT & ran(sshort_bv16) = BV16 & dom(schar_sshort) = SCHAR*SCHAR & ran(schar_sshort) = SSHORT & 1 = 2**0 & 2 = 2**1 & 4 = 2**2 & 8 = 2**3 & 16 = 2**4 & 32 = 2**5 & 64 = 2**6 & 128 = 2**7 & 256 = 2**8 & 512 = 2**9 & 1024 = 2**10 & 2048 = 2**11 & 4096 = 2**12 & 8192 = 2**13 & 16384 = 2**14 & 32768 = 2**15 & 65536 = 2**16 & card(bv16_ushort) = 65536 & card(ushort_bv16) = 65536 & card(uchar_ushort) = 65536 & ushort_bv16 = bv16_ushort~ & USHORT_MAX: INTEGER & USHORT_MIN: INTEGER & dom(bv16_ushort) = BV16 & ran(bv16_ushort) = USHORT & dom(ushort_bv16) = USHORT & ran(ushort_bv16) = BV16 & dom(uchar_ushort) = UCHAR*UCHAR & ran(uchar_ushort) = USHORT & 1 = 2**0 & 2 = 2**1 & 4 = 2**2 & 8 = 2**3 & 16 = 2**4 & 32 = 2**5 & 64 = 2**6 & 128 = 2**7 & 256 = 2**8 & 512 = 2**9 & 1024 = 2**10 & 2048 = 2**11 & 4096 = 2**12 & 8192 = 2**13 & 16384 = 2**14 & 32768 = 2**15 & 65536 = 2**16 & 2**0 = 1 & 2**1 = 2 & 2**2 = 4 & 2**3 = 8 & 2**4 = 16 & 2**5 = 32 & 2**6 = 64 & 2**7 = 128 & (-2)**7 = -128 & 2**8 = 256 & 2**9 = 512 & 2**10 = 1024 & 2**11 = 2048 & 2**12 = 4096 & 2**13 = 8192 & 2**14 = 16384 & 2**15 = 32768 & 2**16 = 65536);
("`Included,imported and extended machines assertions'" & ran(mem): POW(BYTE) & dom(mem) = BV16 & !(address,value).(address: BV16 & value: BYTE => mem<+{address|->value}: BV16 +-> BYTE & dom(mem<+{address|->value}) = BV16));
("`Local hypotheses'" & btrue);
(0: dom(uchar_byte));
("`set_pc preconditions in previous components'" & btrue);
("`set_pc preconditions in this component'" & value: USHORT);
("`get_pc preconditions in previous components'" & btrue);
("`get_pc preconditions in this component'" & btrue)

END
&

THEORY EnumerateX IS
(id_reg_8 == {a0,f0,f_0,a_0,b0,c0,b_0,c_0,d0,e0,d_0,e_0,h0,l0,h_0,l_0});
(id_reg_16 == {BC,DE,HL,SP,AF})

END
